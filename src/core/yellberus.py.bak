"""
Yellberus ðŸ•â€ðŸ¦º
The Field Registry - Single Source of Truth for Data Fields.

This module defines all available data fields in the application, their properties,
validation rules, and UI behavior. It replaces scattered constants and configurations.
"""

from dataclasses import dataclass
from typing import Optional, Callable, List, Any
from enum import Enum, auto

class FieldType(Enum):
    TEXT = auto()
    INTEGER = auto()
    REAL = auto()
    BOOLEAN = auto()
    LIST = auto()      # Comma-separated or multiple values
    DURATION = auto()  # Seconds, display as mm:ss
    DATETIME = auto()

@dataclass
class FieldDef:
    """Definition of a single data field."""
    name: str                      # Internal key (e.g., "title")
    ui_header: str                 # Column header (e.g., "Title")
    db_column: str                 # SQL column name (e.g., "MS.Name")
    field_type: FieldType = FieldType.TEXT
    
    # Validation
    required: bool = False
    min_value: Optional[float] = None
    min_length: Optional[int] = None
    
    # UI behavior
    visible: bool = True           # Show in table by default
    editable: bool = True          # Allow inline editing
    sortable: bool = True
    searchable: bool = True
    
    # Filter behavior
    filterable: bool = False          # Show in filter sidebar
    filter_type: str = "list"         # "list", "range", "boolean"
    grouping_function: Optional[Callable[[Any], str]] = None # Logic for branches (e.g. 1984 -> "1980s")
    
    # Mapping
    model_attr: Optional[str] = None  # Song model property (defaults to name)
    portable: bool = True             # If True, must have id3_frame (travels with MP3)

# ==================== THE REGISTRY ====================

# Base Query Template
# This acts as the canonical SELECT statement for retrieving these fields.
# Repositories should append JOINs and WHERE clauses as needed, but try to use this structure.
# ORDER MUST MATCH 'FIELDS' LIST EXACTLY!
# Base Query Parts
# Use these to construct queries with custom WHERE clauses while maintaining column consistency.

QUERY_SELECT = """
    SELECT 
        MS.SourceID,
        MS.TypeID,
        MS.Name,
        GROUP_CONCAT(CASE WHEN R.Name = 'Performer' THEN C.Name END, ', ') AS Performers,
        GROUP_CONCAT(CASE WHEN R.Name = 'Composer' THEN C.Name END, ', ') AS Composers,
        GROUP_CONCAT(CASE WHEN R.Name = 'Lyricist' THEN C.Name END, ', ') AS Lyricists,
        GROUP_CONCAT(CASE WHEN R.Name = 'Producer' THEN C.Name END, ', ') AS Producers,
        S.Groups,
        MS.Duration,
        MS.Source,
        S.RecordingYear,
        S.TempoBPM,
        S.IsDone,
        S.ISRC,
        MS.Notes,
        MS.IsActive
    """

QUERY_FROM = """
    FROM MediaSources MS
    JOIN Songs S ON MS.SourceID = S.SourceID
    LEFT JOIN MediaSourceContributorRoles MSCR ON MS.SourceID = MSCR.SourceID
    LEFT JOIN Contributors C ON MSCR.ContributorID = C.ContributorID
    LEFT JOIN Roles R ON MSCR.RoleID = R.RoleID
"""

QUERY_BASE_WHERE = "WHERE MS.IsActive = 1"

QUERY_GROUP_BY = "GROUP BY MS.SourceID"

# The Canonical Query (Standard Access)
BASE_QUERY = f"{QUERY_SELECT} {QUERY_FROM} {QUERY_BASE_WHERE} {QUERY_GROUP_BY}"

# Helper to group years into decades
def decade_grouper(year: Any) -> str:
    try:
        y = int(year)
        return f"{y // 10 * 10}s"
    except (ValueError, TypeError):
        return "Unknown"

# NOTE: The order of this list MUST match the columns in BASE_QUERY!
FIELDS: List[FieldDef] = [
    FieldDef(
        name="file_id",
        ui_header="ID",
        db_column="MS.SourceID",
        field_type=FieldType.INTEGER,
        visible=False,
        editable=False,
        required=True,
        model_attr="source_id",
        portable=False,  # Local-only: database ID
    ),
    FieldDef(
        name="type_id",
        ui_header="Type",
        db_column="MS.TypeID",
        field_type=FieldType.INTEGER,
        visible=False,
        editable=False,
        filterable=True,
        portable=False,  # Local-only: type classification
    ),
    FieldDef(
        name="title",
        ui_header="Title",
        db_column="MS.Name",
        required=True,
        min_length=1,
        searchable=True,
        filterable=False,
    ),
    FieldDef(
        name="performers",
        ui_header="Artist",
        db_column="Performers", 
        field_type=FieldType.LIST,
        required=True,
        min_length=1,
        filterable=True,
        searchable=True,
    ),
    FieldDef(
        name="composers",
        ui_header="Composer",
        db_column="Composers",
        field_type=FieldType.LIST,
        required=True,
        min_length=1,
        filterable=True,
        searchable=True,
    ),
    FieldDef(
        name="lyricists",
        ui_header="Lyricist",
        db_column="Lyricists",
        field_type=FieldType.LIST,
        visible=False,
        filterable=True,
    ),
    FieldDef(
        name="producers",
        ui_header="Producer",
        db_column="Producers",
        field_type=FieldType.LIST,
        visible=False,
        filterable=True,
    ),
    FieldDef(
        name="groups",
        ui_header="Groups",
        db_column="S.Groups",
        field_type=FieldType.LIST,
        visible=False,
        filterable=True,
    ),
    FieldDef(
        name="duration",
        ui_header="Duration",
        db_column="MS.Duration",
        field_type=FieldType.DURATION,
        required=True,
        min_value=30,
        portable=False,  # Local-only: calculated from audio stream
    ),
    FieldDef(
        name="path",
        ui_header="Path",
        db_column="MS.Source",
        visible=False,
        editable=False,
        required=True,
        model_attr="source",
        portable=False,  # Local-only: filesystem path
    ),
    FieldDef(
        name="recording_year",
        ui_header="Year",
        db_column="S.RecordingYear",
        field_type=FieldType.INTEGER,
        required=True,
        filterable=True,
        grouping_function=decade_grouper,
    ),
    FieldDef(
        name="bpm",
        ui_header="BPM",
        db_column="S.TempoBPM",
        field_type=FieldType.INTEGER,
        min_value=0,
        filterable=True,
        filter_type="range",
    ),
    FieldDef(
        name="is_done",
        ui_header="Status",
        db_column="S.IsDone",
        field_type=FieldType.BOOLEAN,
        filterable=True,
        filter_type="boolean",
        portable=False,  # Local-only: station-specific status
    ),
    FieldDef(
        name="isrc",
        ui_header="ISRC",
        db_column="S.ISRC",
        visible=False,
    ),
    FieldDef(
        name="notes",
        ui_header="Notes",
        db_column="MS.Notes",
        visible=False,
        portable=False,
    ),
    FieldDef(
        name="is_active",
        ui_header="Active",
        db_column="MS.IsActive",
        field_type=FieldType.BOOLEAN,
        visible=False,
        portable=False,
    ),
]

# ==================== HELPERS ====================

def get_field(name: str) -> Optional[FieldDef]:
    """Lookup a field by name."""
    return next((f for f in FIELDS if f.name == name), None)

def get_visible_fields() -> List[FieldDef]:
    """Get fields that should appear in the table."""
    return [f for f in FIELDS if f.visible]

def get_filterable_fields() -> List[FieldDef]:
    """Get fields that should appear in the filter sidebar."""
    return [f for f in FIELDS if f.filterable]

def get_required_fields() -> List[FieldDef]:
    """Get fields marked as required for validation."""
    return [f for f in FIELDS if f.required]

# ==================== SCHEMA VALIDATION ====================

class SchemaError(Exception):
    """Raised when schema validation fails."""
    pass

def yell(message: str) -> None:
    """
    Report a schema or mapping error.
    Called by Song when it can't map a value.
    """
    # For now, just print. Could raise, log to file, etc.
    print(f"ðŸ•â€ðŸ¦º YELLBERUS: {message}")

def validate_schema() -> None:
    """
    Cross-check FIELDS against id3_frames.json and Song model.
    Raises SchemaError if mismatches are found.
    
    Checks:
    1. Portable fields have id3_frame defined
    2. id3_frame exists in id3_frames.json with 'field' mapping
    3. JSON 'field' value has matching Song attribute (or alias)
    4. Local fields don't have id3_frame
    
    Call this at app startup or in tests to catch schema drift early.
    """
    import json
    import os
    from src.data.models.song import Song
    
    errors = []
    
    # Load id3_frames.json
    base_dir = os.path.dirname(os.path.abspath(__file__))
    json_path = os.path.join(base_dir, '..', 'resources', 'id3_frames.json')
    
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            id3_frames = json.load(f)
    except Exception as e:
        errors.append(f"âŒ Failed to load id3_frames.json: {e}")
        id3_frames = {}
    
    # Build reverse lookup: field_name -> frame_code
    field_to_frame = {}
    for frame_code, frame_info in id3_frames.items():
        if isinstance(frame_info, dict) and 'field' in frame_info:
            field_to_frame[frame_info['field']] = frame_code
    
    # Known aliases (JSON field name -> Song attribute)
    attr_map = {
        'file_id': 'source_id',
        'path': 'source',
        'title': 'name',
    }
    
    for field in FIELDS:
        # Look up frame code from JSON using field name
        frame_code = field_to_frame.get(field.name)
        
        # Check 1: Portable fields must have a frame in JSON
        if field.portable and not frame_code:
            errors.append(f"âŒ Portable field '{field.name}' has no ID3 frame mapping in id3_frames.json")
            continue
        
        # For portable fields, verify the full chain
        if field.portable and frame_code:
            frame_info = id3_frames.get(frame_code, {})
            if isinstance(frame_info, dict):
                json_field = frame_info.get('field')
                
                # Check 2: JSON field maps to Song attribute
                attr = attr_map.get(json_field, json_field)
                if attr not in Song.__dataclass_fields__ and not hasattr(Song, attr):
                    errors.append(f"âŒ JSON field '{json_field}' â†’ Song missing attribute '{attr}'")
        
        # For local fields, check Song has the attribute
        if not field.portable:
            attr = field.model_attr or field.name
            attr = attr_map.get(attr, attr)
            if attr not in Song.__dataclass_fields__ and not hasattr(Song, attr):
                errors.append(f"âŒ Local field '{field.name}' â†’ Song missing attribute '{attr}'")
    
    if errors:
        raise SchemaError("YELLBERUS SCHEMA MISMATCH:\n" + "\n".join(errors))

def row_to_tagged_tuples(row: tuple) -> list:
    """
    Convert a Yellberus query result row to tagged tuples.
    Returns: [(value, id3_frame_or_field_name), ...]
    
    For portable fields: looks up id3_frame from JSON using field name
    For local fields: uses field name prefixed with "_" (e.g., "_file_id")
    
    Song will use these to look up mappings in id3_frames.json.
    """
    import json
    import os
    
    # Load id3_frames.json to find frame codes
    base_dir = os.path.dirname(os.path.abspath(__file__))
    json_path = os.path.join(base_dir, '..', 'resources', 'id3_frames.json')
    
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            id3_frames = json.load(f)
    except Exception:
        id3_frames = {}
    
    # Build reverse lookup: field_name -> frame_code
    field_to_frame = {}
    for frame_code, frame_info in id3_frames.items():
        if isinstance(frame_info, dict) and 'field' in frame_info:
            field_to_frame[frame_info['field']] = frame_code
    
    result = []
    for i, field in enumerate(FIELDS):
        if i >= len(row):
            break
            
        value = row[i]
        
        # Handle list types (comma-separated strings from DB)
        if field.field_type == FieldType.LIST and value:
            value = [v.strip() for v in str(value).split(',') if v.strip()]
        
        # Look up ID3 frame from JSON
        frame_code = field_to_frame.get(field.name)
        
        if field.portable and frame_code:
            # Portable field: tag with ID3 frame code
            result.append((value, frame_code))
        else:
            # Local field or no frame found: tag with underscore-prefixed field name
            result.append((value, f"_{field.name}"))
    
    return result
